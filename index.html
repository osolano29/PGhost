// ================ CONFIGURACIÓN INICIAL ================
import { CONTRACT_CONFIG, AMOY_CONFIG } from './ghost-token.js';

// Variables globales
let web3, contract, userAddress, isOwner = false, isAuxiliary = false;
let currentGasEstimate = 0;
let currentGasUsed = 0;

// Elementos del DOM
const DOM = {
    // Elementos de conexión
    connectWallet: document.getElementById('connectWallet'),
    disconnectWallet: document.getElementById('disconnectWallet'),
    networkStatus: document.getElementById('networkStatus'),
    networkStatusText: document.getElementById('networkStatusText'),
    walletInfo: document.getElementById('walletInfo'),
    walletAddress: document.getElementById('walletAddress'),
    
    // Información del token
    tokenBalance: document.getElementById('tokenBalance'),
    totalSupply: document.getElementById('totalSupply'),
    contractPausedStatus: document.getElementById('contractPausedStatus'),
    walletPausedStatus: document.getElementById('walletPausedStatus'),
    refreshBalance: document.getElementById('refreshBalance'),
    
    // Transferencias
    transferTokens: document.getElementById('transferTokens'),
    recipientAddress: document.getElementById('recipientAddress'),
    transferAmount: document.getElementById('transferAmount'),
    
    // Quemado
    burnTokens: document.getElementById('burnTokens'),
    burnAmount: document.getElementById('burnAmount'),
    
    // Seguridad
    pauseWallet: document.getElementById('pauseWallet'),
    unpauseWallet: document.getElementById('unpauseWallet'),
    
    // Funciones de owner
    mintTokens: document.getElementById('mintTokens'),
    mintAddress: document.getElementById('mintAddress'),
    mintAmount: document.getElementById('mintAmount'),
    pauseContract: document.getElementById('pauseContract'),
    unpauseContract: document.getElementById('unpauseContract'),
    
    // Sistema de recovery
    approveRecoveryBtn: document.getElementById('approveRecoveryBtn'),
    executeRecoveryBtn: document.getElementById('executeRecoveryBtn'),
    recoveryNominee: document.getElementById('recoveryNominee'),
    recoveryDeadline: document.getElementById('recoveryDeadline'),
    recoveryApproved: document.getElementById('recoveryApproved'),
    recoveryRemainingTime: document.getElementById('recoveryRemainingTime'),
    
    // Funciones de auxiliar
    setAuxiliaryBtn: document.getElementById('setAuxiliaryBtn'),
    claimOwnershipBtn: document.getElementById('claimOwnershipBtn'),
    newAuxiliary: document.getElementById('newAuxiliary'),
    auxiliaryAddress: document.getElementById('auxiliaryAddress'),
    
    // Aprobación de gastos
    spenderContract: document.getElementById('spenderContract'),
    approvalAmount: document.getElementById('approvalAmount'),
    approvalGasEstimate: document.getElementById('approvalGasEstimate'),
    approvalGasUsed: document.getElementById('approvalGasUsed'),
    estimateApprovalGas: document.getElementById('estimateApprovalGas'),
    approveTokens: document.getElementById('approveTokens'),
    
    // UI Elements
    loader: document.getElementById('loader'),
    loaderText: document.getElementById('loaderText'),
    notification: document.getElementById('notification'),
    notificationMessage: document.getElementById('notificationMessage'),
    ownerSection: document.getElementById('ownerSection'),
    auxiliarySection: document.getElementById('auxiliarySection'),
    metaMaskModal: document.getElementById('metaMaskModal')
};

// ================ INICIALIZACIÓN ================
export async function initApp() {
    console.log("Inicializando aplicación...");
    
    if (!verifyCriticalDOM()) {
        console.error("Elementos críticos del DOM no encontrados");
        showNotification("Error inicializando la aplicación", "error");
        return;
    }

    console.log("Configurando event listeners...");
    setupEventListeners();
    setupModalCloseButton();
    setupWalletListeners();
    
    // Verificación inicial silenciosa
    try {
        console.log("Verificando conexión existente...");
        if (window.ethereum?.selectedAddress) {
            await connectWallet(true); // Modo silencioso
            console.log("Conexión automática exitosa");
        }
    } catch (e) {
        console.log("Verificación inicial fallida:", e.message);
    }
    console.log("Inicialización completada");
}

function verifyCriticalDOM() {
    const requiredElements = [
        'connectWallet', 'networkStatus', 'walletInfo',
        'transferTokens', 'burnTokens', 'loader'
    ];
    
    return requiredElements.every(id => {
        const exists = document.getElementById(id) !== null;
        if (!exists) console.error(`Elemento faltante: #${id}`);
        return exists;
    });
}

function setupModalCloseButton() {
    if (!DOM.metaMaskModal) return;
    
    const closeButton = DOM.metaMaskModal.querySelector('.close');
    if (closeButton) {
        closeButton.addEventListener('click', () => {
            DOM.metaMaskModal.style.display = 'none';
        });
    }
}

// ================ GESTIÓN DE CONEXIÓN ================
async function connectWallet(silent = false) {
    try {
        console.log("Iniciando conexión...");
        if (!silent) showLoader("Conectando con MetaMask...");
        
        console.log("Detectando proveedor...");
        const provider = detectProvider();
        console.log("Proveedor detectado:", provider ? "Sí" : "No");
        
        if (!provider) {
            console.log("Mostrando modal de MetaMask");
            if (!silent && !isMetaMaskInstalled()) {
                showMetaMaskModal();
            }
            throw new Error("MetaMask no detectado");
        }

        console.log("Configurando Web3...");
        web3 = new Web3(provider);
        
        console.log("Solicitando cuentas...");
        const accounts = await provider.request({ 
            method: 'eth_requestAccounts' 
        }).catch(err => {
            console.error("Error solicitando cuentas:", err);
            throw new Error("El usuario rechazó la conexión");
        });
        
        console.log("Cuentas obtenidas:", accounts);
        
        if (!accounts?.length) {
            throw new Error("No se obtuvieron cuentas");
        }
        
        userAddress = accounts[0];
        console.log("Usuario conectado:", userAddress);
        
        await setupNetwork();
        initContract();
        await loadInitialData();
        
        updateConnectionStatus(true, userAddress);
        if (!silent) showNotification("Wallet conectada correctamente", "success");
        return true;
        
    } catch (error) {
        console.error("Error en connectWallet:", error);
        if (!silent) {
            handleError(error, "Error al conectar");
        }
        updateConnectionStatus(false);
        return false;
    } finally {
        if (!silent) hideLoader();
    }
}

function disconnectWallet() {
    updateConnectionStatus(false);
    showNotification("Wallet desconectada", "info");
    resetAppState();
}

function updateConnectionStatus(isConnected, address = null) {
    if (!DOM.networkStatus || !DOM.walletInfo || !DOM.connectWallet) return;

    const statusIndicator = DOM.networkStatus.querySelector('.status-indicator');
    
    if (isConnected) {
        DOM.networkStatus.classList.remove('disconnected');
        DOM.networkStatus.classList.add('connected');
        if (DOM.networkStatusText) DOM.networkStatusText.textContent = 'Conectado';
        if (statusIndicator) statusIndicator.className = 'status-indicator connected';
        if (DOM.walletInfo) DOM.walletInfo.style.display = 'flex';
        if (DOM.connectWallet) DOM.connectWallet.style.display = 'none';
        if (DOM.walletAddress && address) DOM.walletAddress.textContent = shortAddress(address);
    } else {
        DOM.networkStatus.classList.remove('connected');
        DOM.networkStatus.classList.add('disconnected');
        if (DOM.networkStatusText) DOM.networkStatusText.textContent = 'Desconectado';
        if (statusIndicator) statusIndicator.className = 'status-indicator disconnected';
        if (DOM.walletInfo) DOM.walletInfo.style.display = 'none';
        if (DOM.connectWallet) DOM.connectWallet.style.display = 'flex';
    }
}

function detectProvider() {
    if (typeof window.ethereum !== 'undefined') {
        // Manejar múltiples proveedores
        if (window.ethereum.providers?.length) {
            return window.ethereum.providers.find(p => p.isMetaMask) || window.ethereum;
        }
        return window.ethereum;
    }
    
    if (typeof window.web3 !== 'undefined' && window.web3.currentProvider?.isMetaMask) {
        return window.web3.currentProvider;
    }
    
    if (window.ethereum?.isMetaMask) {
        return window.ethereum;
    }
    
    return null;
}

function isMetaMaskInstalled() {
    return !!window.ethereum?.isMetaMask || !!window.web3?.currentProvider?.isMetaMask;
}

function showMetaMaskModal() {
    if (DOM.metaMaskModal) {
        DOM.metaMaskModal.style.display = 'flex';
    }
}

function setupWalletListeners() {
    if (window.ethereum) {
        window.ethereum.on('accountsChanged', (accounts) => {
            if (accounts.length > 0) {
                userAddress = accounts[0];
                updateConnectionStatus(true, userAddress);
                loadInitialData();
            } else {
                disconnectWallet();
            }
        });
        
        window.ethereum.on('chainChanged', () => {
            window.location.reload();
        });
    }
}

// ================ INTERACCIÓN CON EL CONTRATO ================
async function setupNetwork() {
    try {
        const chainId = await web3.eth.getChainId();
        if (chainId !== 80002) { // Polygon Amoy
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: AMOY_CONFIG.chainId }]
                });
            } catch (switchError) {
                if (switchError.code === 4902) {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [AMOY_CONFIG]
                    });
                }
                throw new Error("Por favor cambia a Polygon Amoy");
            }
        }
    } catch (error) {
        handleError(error, "Error configurando red");
        throw error;
    }
}

function initContract() {
    contract = new web3.eth.Contract(
        CONTRACT_CONFIG.abi,
        CONTRACT_CONFIG.networks["80002"].address
    );
}

async function loadInitialData() {
    try {
        showLoader("Cargando datos...");
        
        const [
            balance, 
            supply, 
            paused, 
            walletPaused, 
            auxiliary, 
            recoveryData,
            owner
        ] = await Promise.all([
            contract.methods.balanceOf(userAddress).call(),
            contract.methods.totalSupply().call(),
            contract.methods.paused().call(),
            contract.methods.isWalletPaused(userAddress).call(),
            contract.methods.auxiliaryOwner().call(),
            contract.methods.recoveryStatus().call(),
            contract.methods.owner().call()
        ]);
        
        // Actualizar UI
        DOM.tokenBalance.textContent = `${web3.utils.fromWei(balance, 'ether')} GO`;
        DOM.totalSupply.textContent = `${web3.utils.fromWei(supply, 'ether')} GO`;
        updateContractStatusUI(paused);
        updateWalletStatusUI(walletPaused);
        
        // Verificar roles
        isOwner = userAddress.toLowerCase() === owner.toLowerCase();
        isAuxiliary = userAddress.toLowerCase() === auxiliary.toLowerCase();
        toggleRoleSections();
        
        // Actualizar datos adicionales
        updateRecoveryUI(recoveryData);
        updateAuxiliaryUI(auxiliary);
        
    } catch (error) {
        handleError(error, "Error cargando datos");
    } finally {
        hideLoader();
    }
}

function updateContractStatusUI(paused) {
    if (DOM.contractPausedStatus) {
        DOM.contractPausedStatus.textContent = paused ? '⛔ PAUSADO' : '✅ Activo';
        DOM.contractPausedStatus.className = paused ? 'status-badge paused' : 'status-badge active';
    }
}

function updateWalletStatusUI(paused) {
    if (DOM.walletPausedStatus) {
        DOM.walletPausedStatus.textContent = paused ? '⛔ PAUSADA' : '✅ Activa';
        DOM.walletPausedStatus.className = paused ? 'status-badge paused' : 'status-badge active';
    }
}

function updateRecoveryUI({nominee, deadline, approved, remainingTime}) {
    if (DOM.recoveryNominee) {
        DOM.recoveryNominee.textContent = nominee === '0x0000000000000000000000000000000000000000' 
            ? 'Ninguno' 
            : shortAddress(nominee);
    }
    
    if (DOM.recoveryDeadline) {
        DOM.recoveryDeadline.textContent = deadline === '0' 
            ? 'N/A' 
            : new Date(deadline * 1000).toLocaleString();
    }
    
    if (DOM.recoveryApproved) {
        DOM.recoveryApproved.textContent = approved ? '✅ Aprobado' : '❌ No aprobado';
    }
    
    if (DOM.recoveryRemainingTime) {
        if (remainingTime > 0) {
            const days = Math.floor(remainingTime / 86400);
            const hours = Math.floor((remainingTime % 86400) / 3600);
            DOM.recoveryRemainingTime.textContent = `${days}d ${hours}h`;
            
            if (days < 1) {
                DOM.recoveryRemainingTime.className = 'recovery-value danger';
            } else if (days < 3) {
                DOM.recoveryRemainingTime.className = 'recovery-value warning';
            } else {
                DOM.recoveryRemainingTime.className = 'recovery-value';
            }
        } else {
            DOM.recoveryRemainingTime.textContent = deadline === '0' ? 'N/A' : 'Expirado';
            DOM.recoveryRemainingTime.className = 'recovery-value';
        }
    }
}

function updateAuxiliaryUI(auxiliary) {
    if (DOM.auxiliaryAddress) {
        DOM.auxiliaryAddress.textContent = auxiliary === '0x0000000000000000000000000000000000000000' 
            ? 'No asignado' 
            : shortAddress(auxiliary);
    }
}

function toggleRoleSections() {
    if (DOM.ownerSection) {
        DOM.ownerSection.style.display = isOwner ? 'block' : 'none';
    }
    if (DOM.auxiliarySection) {
        DOM.auxiliarySection.style.display = isAuxiliary ? 'block' : 'none';
    }
}

// ================ FUNCIONES DE TRANSACCIÓN ================
async function transferTokens() {
    try {
        const recipient = DOM.recipientAddress.value;
        const amount = DOM.transferAmount.value;
        
        validateAddress(recipient);
        validateAmount(amount);
        
        showLoader("Estimando gas...");
        const gasEstimate = await contract.methods.transfer(
            recipient, 
            web3.utils.toWei(amount, 'ether')
        ).estimateGas({ from: userAddress });
        
        const proceed = await showGasConfirmation(gasEstimate, "transferencia");
        if (!proceed) {
            showNotification("Transacción cancelada por el usuario", "info");
            return;
        }
        
        showLoader("Enviando transferencia...");
        const tx = await contract.methods.transfer(
            recipient, 
            web3.utils.toWei(amount, 'ether')
        ).send({ 
            from: userAddress,
            gas: gasEstimate + 10000 // Margen adicional
        });
        
        showNotification(`Transferencia exitosa! Gas usado: ${tx.gasUsed}`, "success");
        await loadInitialData();
        return tx;
        
    } catch (error) {
        if (error.receipt && error.receipt.gasUsed) {
            handleError(error, `Error en transferencia (Gas usado: ${error.receipt.gasUsed})`);
        } else {
            handleError(error, "Error en transferencia");
        }
        throw error;
    } finally {
        hideLoader();
    }
}

async function burnTokens() {
    try {
        const amount = DOM.burnAmount.value;
        validateAmount(amount);
        
        showLoader("Estimando gas...");
        const gasEstimate = await contract.methods.burn(
            web3.utils.toWei(amount, 'ether')
        ).estimateGas({ from: userAddress });
        
        const proceed = await showGasConfirmation(gasEstimate, "quema");
        if (!proceed) {
            showNotification("Transacción cancelada por el usuario", "info");
            return;
        }
        
        showLoader("Procesando quema...");
        const tx = await contract.methods.burn(
            web3.utils.toWei(amount, 'ether')
        ).send({ 
            from: userAddress,
            gas: gasEstimate + 10000
        });
        
        showNotification(`Tokens quemados exitosamente! Gas usado: ${tx.gasUsed}`, "success");
        await loadInitialData();
        return tx;
        
    } catch (error) {
        if (error.receipt && error.receipt.gasUsed) {
            handleError(error, `Error quemando tokens (Gas usado: ${error.receipt.gasUsed})`);
        } else {
            handleError(error, "Error quemando tokens");
        }
        throw error;
    } finally {
        hideLoader();
    }
}

async function mintTokens() {
    if (!isOwner) {
        showNotification("Solo el owner puede mintear tokens", "error");
        return;
    }
    
    try {
        const recipient = DOM.mintAddress.value;
        const amount = DOM.mintAmount.value;
        
        validateAddress(recipient);
        validateAmount(amount);
        
        showLoader("Estimando gas...");
        const gasEstimate = await contract.methods.mint(
            recipient,
            web3.utils.toWei(amount, 'ether')
        ).estimateGas({ from: userAddress });
        
        const proceed = await showGasConfirmation(gasEstimate, "minteo");
        if (!proceed) {
            showNotification("Transacción cancelada por el usuario", "info");
            return;
        }
        
        showLoader("Minteando tokens...");
        const tx = await contract.methods.mint(
            recipient,
            web3.utils.toWei(amount, 'ether')
        ).send({ 
            from: userAddress,
            gas: gasEstimate + 10000
        });
        
        showNotification(`Tokens minteados exitosamente! Gas usado: ${tx.gasUsed}`, "success");
        await loadInitialData();
        return tx;
        
    } catch (error) {
        if (error.receipt && error.receipt.gasUsed) {
            handleError(error, `Error minteando tokens (Gas usado: ${error.receipt.gasUsed})`);
        } else {
            handleError(error, "Error minteando tokens");
        }
        throw error;
    } finally {
        hideLoader();
    }
}

async function toggleWalletPause(pause) {
    try {
        const action = pause ? "pausar" : "reanudar";
        showLoader(`Estimando gas para ${action} wallet...`);
        
        const method = pause ? 'pauseMyWallet' : 'unpauseMyWallet';
        const gasEstimate = await contract.methods[method]()
            .estimateGas({ from: userAddress });
        
        const proceed = await showGasConfirmation(gasEstimate, `${action} wallet`);
        if (!proceed) {
            showNotification("Transacción cancelada por el usuario", "info");
            return;
        }
        
        showLoader(`${pause ? "Pausando" : "Reanudando"} wallet...`);
        const tx = await contract.methods[method]().send({ 
            from: userAddress,
            gas: gasEstimate + 10000
        });
        
        showNotification(
            `Wallet ${pause ? "pausada" : "reanudada"} correctamente! Gas usado: ${tx.gasUsed}`, 
            "success"
        );
        await loadInitialData();
        return tx;
        
    } catch (error) {
        if (error.receipt && error.receipt.gasUsed) {
            handleError(error, `Error ${pause ? "pausando" : "reanudando"} wallet (Gas usado: ${error.receipt.gasUsed})`);
        } else {
            handleError(error, pause ? "Error pausando wallet" : "Error reanudando wallet");
        }
        throw error;
    } finally {
        hideLoader();
    }
}

async function toggleContractPause(pause) {
    if (!isOwner) {
        showNotification("Solo el owner puede pausar el contrato", "error");
        return;
    }
    
    try {
        const action = pause ? "pausar" : "reanudar";
        showLoader(`Estimando gas para ${action} contrato...`);
        
        const method = pause ? 'pause' : 'unpause';
        const gasEstimate = await contract.methods[method]()
            .estimateGas({ from: userAddress });
        
        const proceed = await showGasConfirmation(gasEstimate, `${action} contrato`);
        if (!proceed) {
            showNotification("Transacción cancelada por el usuario", "info");
            return;
        }
        
        showLoader(`${pause ? "Pausando" : "Reanudando"} contrato...`);
        const tx = await contract.methods[method]().send({ 
            from: userAddress,
            gas: gasEstimate + 10000
        });
        
        showNotification(
            `Contrato ${pause ? "pausado" : "reanudado"} correctamente! Gas usado: ${tx.gasUsed}`, 
            "success"
        );
        await loadInitialData();
        return tx;
        
    } catch (error) {
        if (error.receipt && error.receipt.gasUsed) {
            handleError(error, `Error ${pause ? "pausando" : "reanudando"} contrato (Gas usado: ${error.receipt.gasUsed})`);
        } else {
            handleError(error, pause ? "Error pausando contrato" : "Error reanudando contrato");
        }
        throw error;
    } finally {
        hideLoader();
    }
}

async function setAuxiliaryOwner() {
    if (!isOwner) {
        showNotification("Solo el owner puede asignar auxiliar", "error");
        return;
    }
    
    try {
        const newAuxiliary = DOM.newAuxiliary.value;
        validateAddress(newAuxiliary);
        
        showLoader("Estimando gas...");
        const gasEstimate = await contract.methods.setAuxiliaryOwner(newAuxiliary)
            .estimateGas({ from: userAddress });
        
        const proceed = await showGasConfirmation(gasEstimate, "actualizar auxiliar");
        if (!proceed) {
            showNotification("Transacción cancelada por el usuario", "info");
            return;
        }
        
        showLoader("Actualizando auxiliar...");
        const tx = await contract.methods.setAuxiliaryOwner(newAuxiliary)
            .send({ 
                from: userAddress,
                gas: gasEstimate + 10000
            });
        
        showNotification(`Auxiliar actualizado correctamente! Gas usado: ${tx.gasUsed}`, "success");
        await loadInitialData();
        return tx;
        
    } catch (error) {
        if (error.receipt && error.receipt.gasUsed) {
            handleError(error, `Error asignando auxiliar (Gas usado: ${error.receipt.gasUsed})`);
        } else {
            handleError(error, "Error asignando auxiliar");
        }
        throw error;
    } finally {
        hideLoader();
    }
}

async function approveRecovery(approve) {
    if (!isOwner) {
        showNotification("Solo el owner puede aprobar recovery", "error");
        return;
    }
    
    try {
        const action = approve ? "aprobar" : "rechazar";
        showLoader(`Estimando gas para ${action} recovery...`);
        
        const gasEstimate = await contract.methods.approveRecovery(approve)
            .estimateGas({ from: userAddress });
        
        const proceed = await showGasConfirmation(gasEstimate, `${action} recovery`);
        if (!proceed) {
            showNotification("Transacción cancelada por el usuario", "info");
            return;
        }
        
        showLoader(`${approve ? "Aprobando" : "Rechazando"} recovery...`);
        const tx = await contract.methods.approveRecovery(approve)
            .send({ 
                from: userAddress,
                gas: gasEstimate + 10000
            });
        
        showNotification(
            `Recovery ${approve ? "aprobado" : "rechazado"} correctamente! Gas usado: ${tx.gasUsed}`, 
            "success"
        );
        await loadInitialData();
        return tx;
        
    } catch (error) {
        if (error.receipt && error.receipt.gasUsed) {
            handleError(error, `Error en aprobación de recovery (Gas usado: ${error.receipt.gasUsed})`);
        } else {
            handleError(error, "Error en aprobación de recovery");
        }
        throw error;
    } finally {
        hideLoader();
    }
}

async function executeRecovery() {
    try {
        showLoader("Estimando gas para ejecutar recovery...");
        const gasEstimate = await contract.methods.executeRecovery()
            .estimateGas({ from: userAddress });
        
        const proceed = await showGasConfirmation(gasEstimate, "ejecutar recovery");
        if (!proceed) {
            showNotification("Transacción cancelada por el usuario", "info");
            return;
        }
        
        showLoader("Ejecutando recovery...");
        const tx = await contract.methods.executeRecovery()
            .send({ 
                from: userAddress,
                gas: gasEstimate + 10000
            });
        
        showNotification(`¡Ownership transferido exitosamente! Gas usado: ${tx.gasUsed}`, "success");
        await loadInitialData();
        return tx;
        
    } catch (error) {
        if (error.receipt && error.receipt.gasUsed) {
            handleError(error, `Error ejecutando recovery (Gas usado: ${error.receipt.gasUsed})`);
        } else {
            handleError(error, "Error ejecutando recovery");
        }
        throw error;
    } finally {
        hideLoader();
    }
}

async function claimOwnership() {
    if (!isAuxiliary) {
        showNotification("Solo el auxiliar puede iniciar recovery", "error");
        return;
    }
    
    try {
        showLoader("Estimando gas para iniciar recovery...");
        const gasEstimate = await contract.methods.claimOwnershipFromAuxiliary()
            .estimateGas({ from: userAddress });
        
        const proceed = await showGasConfirmation(gasEstimate, "iniciar recovery");
        if (!proceed) {
            showNotification("Transacción cancelada por el usuario", "info");
            return;
        }
        
        showLoader("Iniciando proceso de recovery...");
        const tx = await contract.methods.claimOwnershipFromAuxiliary()
            .send({ 
                from: userAddress,
                gas: gasEstimate + 10000
            });
        
        showNotification(`Proceso de recovery iniciado! Gas usado: ${tx.gasUsed}`, "success");
        await loadInitialData();
        return tx;
        
    } catch (error) {
        if (error.receipt && error.receipt.gasUsed) {
            handleError(error, `Error iniciando recovery (Gas usado: ${error.receipt.gasUsed})`);
        } else {
            handleError(error, "Error iniciando recovery");
        }
        throw error;
    } finally {
        hideLoader();
    }
}

// ================ FUNCIONES DE APROBACIÓN ================
async function estimateApprovalGas() {
    try {
        const spender = DOM.spenderContract.value;
        const amount = DOM.approvalAmount.value;
        
        validateAddress(spender);
        validateAmount(amount);
        
        showLoader("Estimando gas...");
        
        // Verificar si el contrato está autorizado
        const isAllowed = await contract.methods.isContractAllowed(spender).call();
        if (!isAllowed) {
            throw new Error("El contrato no está en la lista de permitidos");
        }
        
        const amountInWei = web3.utils.toWei(amount, 'ether');
        const gasEstimate = await contract.methods.approve(spender, amountInWei)
            .estimateGas({ from: userAddress });
        
        DOM.approvalGasEstimate.textContent = gasEstimate;
        showNotification(`Gas estimado: ${gasEstimate}`, "info");
        return gasEstimate;
        
    } catch (error) {
        handleError(error, "Error estimando gas");
        throw error;
    } finally {
        hideLoader();
    }
}

async function approveTokens() {
    try {
        const spender = DOM.spenderContract.value;
        const amount = DOM.approvalAmount.value;
        
        validateAddress(spender);
        validateAmount(amount);
        
        // Verificar si el contrato está autorizado
        const isAllowed = await contract.methods.isContractAllowed(spender).call();
        if (!isAllowed) {
            throw new Error("El contrato no está en la lista de permitidos");
        }
        
        // Obtener estimación de gas
        const gasEstimate = await estimateApprovalGas();
        if (!gasEstimate) return;
        
        const proceed = await showGasConfirmation(gasEstimate, "aprobación");
        if (!proceed) {
            showNotification("Transacción cancelada por el usuario", "info");
            return;
        }
        
        showLoader("Enviando aprobación...");
        
        const amountInWei = web3.utils.toWei(amount, 'ether');
        const tx = await contract.methods.approve(spender, amountInWei)
            .send({ 
                from: userAddress,
                gas: gasEstimate + 10000 // Margen adicional
            });
        
        // Actualizar gas usado
        DOM.approvalGasUsed.textContent = tx.gasUsed;
        
        showNotification(`Aprobación exitosa! Gas usado: ${tx.gasUsed}`, "success");
        return tx;
        
    } catch (error) {
        // Si la transacción falló pero se ejecutó, capturar el gas usado
        if (error.receipt && error.receipt.gasUsed) {
            DOM.approvalGasUsed.textContent = error.receipt.gasUsed;
            handleError(error, `Error en aprobación (Gas usado: ${error.receipt.gasUsed})`);
        } else {
            handleError(error, "Error en aprobación");
        }
        throw error;
    } finally {
        hideLoader();
    }
}

// ================ FUNCIONES AUXILIARES ================
function setupEventListeners() {
    // Conexión
    if (DOM.connectWallet) DOM.connectWallet.addEventListener('click', connectWallet);
    if (DOM.disconnectWallet) DOM.disconnectWallet.addEventListener('click', disconnectWallet);
    if (DOM.refreshBalance) DOM.refreshBalance.addEventListener('click', loadInitialData);
    
    // Transferencias
    if (DOM.transferTokens) DOM.transferTokens.addEventListener('click', transferTokens);
    if (DOM.burnTokens) DOM.burnTokens.addEventListener('click', burnTokens);
    
    // Seguridad
    if (DOM.pauseWallet) DOM.pauseWallet.addEventListener('click', () => toggleWalletPause(true));
    if (DOM.unpauseWallet) DOM.unpauseWallet.addEventListener('click', () => toggleWalletPause(false));
    
    // Owner functions
    if (DOM.mintTokens) DOM.mintTokens.addEventListener('click', mintTokens);
    if (DOM.pauseContract) DOM.pauseContract.addEventListener('click', () => toggleContractPause(true));
    if (DOM.unpauseContract) DOM.unpauseContract.addEventListener('click', () => toggleContractPause(false));
    if (DOM.setAuxiliaryBtn) DOM.setAuxiliaryBtn.addEventListener('click', setAuxiliaryOwner);
    
    // Recovery
    if (DOM.approveRecoveryBtn) DOM.approveRecoveryBtn.addEventListener('click', () => approveRecovery(true));
    if (DOM.executeRecoveryBtn) DOM.executeRecoveryBtn.addEventListener('click', executeRecovery);
    if (DOM.claimOwnershipBtn) DOM.claimOwnershipBtn.addEventListener('click', claimOwnership);
    
    // Aprobación
    if (DOM.estimateApprovalGas) DOM.estimateApprovalGas.addEventListener('click', estimateApprovalGas);
    if (DOM.approveTokens) DOM.approveTokens.addEventListener('click', approveTokens);
}

function validateAddress(address) {
    if (!web3.utils.isAddress(address)) {
        throw new Error("Dirección inválida");
    }
}

function validateAmount(amount) {
    if (!amount || isNaN(amount) || Number(amount) <= 0) {
        throw new Error("Cantidad inválida");
    }
}

function shortAddress(address) {
    return address ? `${address.substring(0, 6)}...${address.substring(38)}` : "N/A";
}

function resetAppState() {
    userAddress = null;
    isOwner = false;
    isAuxiliary = false;
    
    if (DOM.tokenBalance) DOM.tokenBalance.textContent = "0.00 GO";
    if (DOM.totalSupply) DOM.totalSupply.textContent = "-";
    if (DOM.contractPausedStatus) DOM.contractPausedStatus.textContent = "-";
    if (DOM.walletPausedStatus) DOM.walletPausedStatus.textContent = "-";
    if (DOM.ownerSection) DOM.ownerSection.style.display = 'none';
    if (DOM.auxiliarySection) DOM.auxiliarySection.style.display = 'none';
}

// ================ MANEJO DE GAS ================
async function showGasConfirmation(gasEstimate, actionName) {
    return new Promise((resolve) => {
        // Crear el modal de confirmación
        const modal = document.createElement('div');
        modal.className = 'gas-confirmation-modal';
        modal.innerHTML = `
            <div class="modal-content">
                <h3>Confirmar ${actionName}</h3>
                <div class="gas-info">
                    <p>Gas estimado: <strong>${gasEstimate}</strong></p>
                    <p>Límite de gas sugerido: <strong>${gasEstimate + 10000}</strong></p>
                </div>
                <div class="modal-actions">
                    <button id="cancelTx" class="btn-secondary">Cancelar</button>
                    <button id="confirmTx" class="btn-primary">Confirmar</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Event listeners
        document.getElementById('cancelTx').addEventListener('click', () => {
            document.body.removeChild(modal);
            resolve(false);
        });
        
        document.getElementById('confirmTx').addEventListener('click', () => {
            document.body.removeChild(modal);
            resolve(true);
        });
    });
}

// ================ MANEJO DE UI ================
function showLoader(message = "Procesando...") {
    if (DOM.loaderText) DOM.loaderText.textContent = message;
    if (DOM.loader) DOM.loader.style.display = 'flex';
}

function hideLoader() {
    if (DOM.loader) DOM.loader.style.display = 'none';
}

function showNotification(message, type = "success") {
    if (!DOM.notification || !DOM.notificationMessage) return;
    
    DOM.notificationMessage.textContent = message;
    DOM.notification.className = `notification show ${type}`;
    
    setTimeout(() => {
        DOM.notification.classList.remove('show');
    }, 5000);
}

function handleError(error, context = "") {
    console.error(context, error);
    
    let message = error.message;
    if (error.code === 4001) {
        message = "Transacción cancelada por el usuario";
    } else if (error.message.includes("user denied transaction")) {
        message = "Transacción rechazada";
    } else if (error.message.includes("insufficient funds")) {
        message = "Fondos insuficientes para gas";
    } else if (error.message.includes("wallet paused")) {
        message = "Wallet pausada - operación no permitida";
    } else if (error.message.includes("contract paused")) {
        message = "Contrato pausado - operación no disponible";
    } else if (error.message.includes("revert")) {
        // Extraer el mensaje de revert si está disponible
        const revertMsg = error.message.match(/reason string: '(.+?)'/);
        message = revertMsg ? revertMsg[1] : message;
    }
    
    showNotification(`${context}: ${message}`, "error");
}

// Inicialización de listeners
if (document.readyState !== 'loading') {
    initApp();
} else {
    document.addEventListener('DOMContentLoaded', initApp);
}

// Configurar listeners de wallet
setupWalletListeners();
